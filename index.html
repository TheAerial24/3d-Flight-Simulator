<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Plane - Inverted Pitch</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }

        #instructions {
            color: white; background: rgba(0, 0, 0, 0.6); padding: 15px;
            border-radius: 8px; display: inline-block;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #dashboard {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6); color: #00ff00;
            padding: 15px; border-radius: 8px;
            font-size: 20px; font-weight: bold;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            text-align: right;
            line-height: 1.5;
        }

        #msg-overlay {
            display: none; position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px; border: 4px solid;
            font-weight: bold; text-shadow: 2px 2px 0 black;
        }

        .crash { color: red; background: rgba(0,0,0,0.8); border-color: red; }
        .landed { color: #00ff00; background: rgba(0,0,0,0.8); border-color: #00ff00; }

        h2 { margin-top: 0; font-family: sans-serif; }
        p { margin: 5px 0; font-family: sans-serif; }
        .key { color: #ffd700; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="instructions">
            <h2>Flight Controls</h2>
            <p><span class="key">0</span> - Cut Engine (0%)</p>
            <p><span class="key">1 - 9</span> - Throttle (10% - 90%)</p>
            <p><span class="key">q</span> - Max Power (100%)</p>
            <p><span class="key">↑</span> - Nose Down (Dive)</p>
            <p><span class="key">↓</span> - Nose Up (Climb)</p>
            <p><span class="key">← / →</span> - Bank Left / Right</p>
            <p><i>To Land: Speed < 40kts + Level Wings</i></p>
        </div>

        <div id="dashboard">
            THR: <span id="throttle-ui">0</span>%<br>
            SPD: <span id="speed-ui">0</span> KTS<br>
            ALT: <span id="alt-ui">0</span> FT
        </div>

        <div id="msg-overlay">
            <span id="msg-text" style="font-size: 48px;">MESSAGE</span><br>
            <span style="font-size: 20px; color: white;">Press R to Reset</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 600);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. LIGHTS ---
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        const d = 200;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- 3. PLANE (Corrected Orientation) ---
        let propeller;
        function createPlane() {
            const planeGroup = new THREE.Group();
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xe74c3c, flatShading: true });
            const whiteMat = new THREE.MeshPhongMaterial({ color: 0xecf0f1, flatShading: true });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50, flatShading: true });

            // Nose points to -Z
            const bodyGeo = new THREE.ConeGeometry(0.8, 4, 8);
            bodyGeo.rotateX(-Math.PI / 2); 
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true; planeGroup.add(body);

            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 1.2), darkMat);
            cockpit.position.set(0, 0.4, 0);
            cockpit.castShadow = true; planeGroup.add(cockpit);

            const wings = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 1.5), whiteMat);
            wings.castShadow = true; planeGroup.add(wings);

            const tail = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), whiteMat);
            tail.position.set(0, 0, 1.6);
            tail.castShadow = true; planeGroup.add(tail);

            const rudder = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 1), whiteMat);
            rudder.position.set(0, 0.6, 1.6);
            rudder.castShadow = true; planeGroup.add(rudder);

            propeller = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.2), darkMat);
            propeller.position.set(0, 0, -2);
            planeGroup.add(propeller);

            return planeGroup;
        }
        const airplane = createPlane();
        scene.add(airplane);

        // --- 4. WORLD ---
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(4000, 4000), 
            new THREE.MeshStandardMaterial({ color: 0x4CAF50 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -50;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Runway
        const runway = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 1000),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
        );
        runway.rotation.x = -Math.PI / 2;
        runway.position.y = -49.9;
        runway.receiveShadow = true;
        scene.add(runway);

        // --- 5. STATE ---
        const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
        
        // Physics
        let speed = 0;
        let throttle = 0; // 0.0 to 1.0
        let rotVel = { x: 0, y: 0, z: 0 }; 
        let isCrashed = false;
        let isLanded = true; // Start on ground
        
        // Constants
        const MAX_SPEED = 2.0;
        const TAKEOFF_SPEED = 0.6;
        const GRAVITY = 0.4;
        const LIFT_FACTOR = 0.45; 
        const FRICTION = 0.96;
        
        // UI Elements
        const uiThrottle = document.getElementById('throttle-ui');
        const uiSpeed = document.getElementById('speed-ui');
        const uiAlt = document.getElementById('alt-ui');
        const msgOverlay = document.getElementById('msg-overlay');
        const msgText = document.getElementById('msg-text');

        // Input Listeners
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true; 
            if (e.key === "ArrowUp") keys.ArrowUp = true;
            if (e.key === "ArrowDown") keys.ArrowDown = true;
            if (e.key === "ArrowLeft") keys.ArrowLeft = true;
            if (e.key === "ArrowRight") keys.ArrowRight = true;
            if (e.code === 'KeyR') resetGame();

            // Throttle Controls
            if (e.key === '0') throttle = 0.0;
            if (e.key === 'q') throttle = 1.0;
            if (e.key >= '1' && e.key <= '9') {
                throttle = parseInt(e.key) / 10;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
            if (e.key === "ArrowUp") keys.ArrowUp = false;
            if (e.key === "ArrowDown") keys.ArrowDown = false;
            if (e.key === "ArrowLeft") keys.ArrowLeft = false;
            if (e.key === "ArrowRight") keys.ArrowRight = false;
        });

        function resetGame() {
            airplane.position.set(0, -48, 0); // Start on runway
            airplane.rotation.set(0, 0, 0);
            speed = 0;
            throttle = 0;
            rotVel = { x:0, y:0, z:0 };
            isCrashed = false;
            isLanded = true;
            msgOverlay.style.display = 'none';
        }

        // Start on ground
        resetGame();

        function updatePhysics() {
            if (isCrashed) return;

            // 1. Throttle Logic
            let targetSpeed = throttle * MAX_SPEED;
            speed = THREE.MathUtils.lerp(speed, targetSpeed, 0.01);

            // 2. Flight Controls (Only work if moving fast enough or in air)
            const controlAuthority = Math.min(speed, 1.0); 

            if (!isLanded || speed > 0.2) {
                // FLIGHT SIM STYLE (INVERTED PITCH)
                // ArrowUp = Positive Rotation (Nose Down)
                // ArrowDown = Negative Rotation (Nose Up)
                if (keys.ArrowUp) rotVel.x += 0.003 * controlAuthority; 
                if (keys.ArrowDown) rotVel.x -= 0.003 * controlAuthority;
                
                if (keys.ArrowLeft) {
                    rotVel.z += 0.003 * controlAuthority;
                    rotVel.y += 0.001 * controlAuthority;
                }
                if (keys.ArrowRight) {
                    rotVel.z -= 0.003 * controlAuthority;
                    rotVel.y -= 0.001 * controlAuthority;
                }
            }

            // Apply Rotation
            airplane.rotateX(rotVel.x);
            airplane.rotateY(rotVel.y);
            airplane.rotateZ(rotVel.z);
            
            // Friction
            rotVel.x *= FRICTION;
            rotVel.y *= FRICTION;
            rotVel.z *= FRICTION;

            // 3. Movement
            airplane.translateZ(-speed);

            // 4. Gravity & Lift
            if (!isLanded) {
                airplane.position.y -= GRAVITY;
                airplane.position.y += speed * LIFT_FACTOR;
            } else {
                // If landed, stick to ground unless we have takeoff speed and pitch up (negative X rot)
                if (speed > TAKEOFF_SPEED && rotVel.x < -0.001) {
                    isLanded = false;
                    msgOverlay.style.display = 'none';
                }
            }

            // 5. Landing / Crash Logic
            const altitude = airplane.position.y + 50;
            
            if (altitude <= 2 && !isLanded) {
                // Get rotation angles (roughly)
                const pitch = airplane.rotation.x % (Math.PI * 2);
                const roll = airplane.rotation.z % (Math.PI * 2);
                
                // Crash Conditions:
                // 1. Too fast (> 35% max speed)
                // 2. Too much bank (> 20 degrees)
                // 3. Nose diving too hard (> 20 degrees)
                const isTooFast = speed > (MAX_SPEED * 0.35);
                const isBadAngle = Math.abs(roll) > 0.35 || Math.abs(pitch) > 0.35;

                if (isTooFast || isBadAngle) {
                    isCrashed = true;
                    msgOverlay.className = 'crash';
                    msgText.innerText = "CRASHED!";
                    msgOverlay.style.display = 'block';
                } else {
                    // Safe Landing
                    isLanded = true;
                    airplane.position.y = -48; // Snap to floor
                    
                    // Auto-level wings slightly on successful landing
                    airplane.rotation.z = 0;
                    airplane.rotation.x = 0;
                    
                    msgOverlay.className = 'landed';
                    msgText.innerText = "LANDED SAFE";
                    msgOverlay.style.display = 'block';
                }
            }
            
            // Floor clamp if landed
            if (isLanded) {
                airplane.position.y = -48;
            }

            // Propeller visual
            if(propeller) propeller.rotation.z += speed;

            // UI Updates
            uiThrottle.innerText = Math.floor(throttle * 100);
            uiSpeed.innerText = Math.floor(speed * 100);
            uiAlt.innerText = Math.floor(Math.max(0, altitude));
        }

        function updateCamera() {
            const offset = new THREE.Vector3(0, 8, 20); 
            const targetPos = offset.applyMatrix4(airplane.matrixWorld);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(airplane.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateCamera();
            
            dirLight.position.x = airplane.position.x + 50;
            dirLight.position.z = airplane.position.z + 50;
            dirLight.target = airplane;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
