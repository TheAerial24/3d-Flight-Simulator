<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cessna 172 Flight Sim</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      font-family: system-ui, sans-serif;
    }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0f0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.4;
      border-radius: 4px;
      pointer-events: none;
      white-space: pre;
    }
    #help {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="help">
    Controls:<br>
    Throttle: 1–9<br>
    Pitch: Up/Down arrows (Down = nose up)<br>
    Roll: Left/Right arrows<br>
    Yaw: A / D<br>
    Mouse: look slightly around (subtle)
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // === Basic Three.js setup ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky blue

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    hemiLight.position.set(0, 100, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(100, 200, 100);
    scene.add(dirLight);

    // === Ground: green plane + white grid ===
    const groundSize = 20000;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x1f7a1f });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(groundSize, 200, 0xffffff, 0xffffff);
    grid.position.y = 0.01; // slightly above to avoid z-fighting
    scene.add(grid);

    // === Simple Cessna 172-ish model ===
    const plane = new THREE.Group();

    // Fuselage
    const fuselageGeo = new THREE.CylinderGeometry(0.7, 0.8, 8, 16);
    const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
    fuselage.rotation.z = Math.PI / 2;
    plane.add(fuselage);

    // Nose cone
    const noseGeo = new THREE.ConeGeometry(0.8, 1.2, 16);
    const noseMat = new THREE.MeshPhongMaterial({ color: 0xcccccc });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.rotation.z = -Math.PI / 2;
    nose.position.set(4.5, 0, 0);
    plane.add(nose);

    // Wings
    const wingGeo = new THREE.BoxGeometry(10, 0.3, 1.5);
    const wingMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, 0.9, 0);
    plane.add(wing);

    // Horizontal stabilizer
    const tailWingGeo = new THREE.BoxGeometry(3, 0.2, 0.8);
    const tailWingMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const tailWing = new THREE.Mesh(tailWingGeo, tailWingMat);
    tailWing.position.set(-3.5, 0.4, 0);
    plane.add(tailWing);

    // Vertical stabilizer
    const tailFinGeo = new THREE.BoxGeometry(0.2, 1.5, 1);
    const tailFinMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const tailFin = new THREE.Mesh(tailFinGeo, tailFinMat);
    tailFin.position.set(-3.5, 1, 0);
    plane.add(tailFin);

    // Simple prop disc
    const propGeo = new THREE.CircleGeometry(1, 32);
    const propMat = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 });
    const prop = new THREE.Mesh(propGeo, propMat);
    prop.rotation.y = Math.PI / 2;
    prop.position.set(5.2, 0, 0);
    plane.add(prop);

    scene.add(plane);

    // Starting position on "ground"
    plane.position.set(0, 5, 0); // small altitude so we don't clip
    plane.rotation.set(0, 0, 0);

    // === Flight physics state ===
    const state = {
      position: plane.position.clone(),
      velocity: new THREE.Vector3(30, 0, 0), // initial forward speed
      orientation: plane.quaternion.clone(),
      angularVelocity: new THREE.Vector3(0, 0, 0),

      throttle: 0.3,   // 0–1
      pitchInput: 0.0, // -1 to 1 (nose down/up)
      rollInput: 0.0,  // -1 to 1
      yawInput: 0.0    // -1 to 1
    };

    // Constants (tuned for "plane-ish" behavior, not real C172 numbers)
    const mass = 1200;          // kg
    const g = 9.81;
    const maxThrust = 3500;     // N
    const wingArea = 16;        // m^2
    const airDensity = 1.225;   // kg/m^3
    const Cd = 0.035;           // drag coefficient
    const liftSlope = 5.5;      // per rad, approximate
    const maxControlTorque = {
      pitch: 0.5,
      roll: 0.7,
      yaw: 0.3
    };
    const angularDamping = 0.3;

    let lastTime = performance.now();

    // === Input handling ===
    const keys = {};

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // Prevent arrow keys from scrolling the page
      if (e.code.startsWith('Arrow')) {
        e.preventDefault();
      }

      // Throttle 1–9
      if (e.key >= '1' && e.key <= '9') {
        const num = parseInt(e.key, 10);
        state.throttle = num / 9; // map 1->0.11, 9->1.0
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Simple mouse look (small offset, not full free look)
    let mouseX = 0;
    let mouseY = 0;
    window.addEventListener('mousemove', (e) => {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      mouseX = (e.clientX - centerX) / centerX;
      mouseY = (e.clientY - centerY) / centerY;
    });

    function updateControls() {
      // Pitch: Down arrow = nose up, Up arrow = nose down
      if (keys['ArrowDown']) {
        state.pitchInput = 1; // nose up
      } else if (keys['ArrowUp']) {
        state.pitchInput = -1; // nose down
      } else {
        state.pitchInput = 0;
      }

      // Roll: Left arrow = roll left, Right arrow = roll right
      if (keys['ArrowLeft']) {
        state.rollInput = -1;
      } else if (keys['ArrowRight']) {
        state.rollInput = 1;
      } else {
        state.rollInput = 0;
      }

      // Yaw: A / D
      if (keys['KeyA']) {
        state.yawInput = -1;
      } else if (keys['KeyD']) {
        state.yawInput = 1;
      } else {
        state.yawInput = 0;
      }
    }

    // === Physics update ===
    function updatePhysics(dt) {
      // Clamp dt to avoid crazy jumps
      dt = Math.min(dt, 0.05);

      // Extract forward, up, right from orientation
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(state.orientation);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(state.orientation); // note: z-axis

      // Thrust
      const thrust = forward.clone().multiplyScalar(maxThrust * state.throttle);

      // Gravity
      const gravity = new THREE.Vector3(0, -mass * g, 0);

      // Airspeed
      const speed = state.velocity.length();
      const velDir = speed > 0.0001 ? state.velocity.clone().divideScalar(speed) : forward.clone();

      // Angle of attack approximate: angle between forward and velocity in pitch axis
      const forwardHoriz = forward.clone();
      const velHoriz = state.velocity.clone();
      // Work in plane defined by forward & up
      const vVert = velHoriz.dot(up);
      const vForward = velHoriz.dot(forward);
      let alpha = 0;
      if (Math.abs(vForward) > 0.1 || Math.abs(vVert) > 0.1) {
        alpha = Math.atan2(vVert, vForward); // radians
      }

      // Lift coefficient (simple linear + stall clamp)
      let Cl = liftSlope * alpha;
      const ClMax = 1.4;
      if (Cl > ClMax) Cl = ClMax;
      if (Cl < -ClMax) Cl = -ClMax;

      const q = 0.5 * airDensity * speed * speed; // dynamic pressure
      const liftMag = q * wingArea * Cl;
      const lift = up.clone().multiplyScalar(liftMag);

      // Drag: quadratic opposite velocity
      const dragMag = q * wingArea * Cd;
      const drag = velDir.clone().multiplyScalar(-dragMag);

      // Total force
      const totalForce = new THREE.Vector3()
        .add(thrust)
        .add(gravity)
        .add(lift)
        .add(drag);

      // Linear acceleration
      const accel = totalForce.clone().divideScalar(mass);

      // Integrate velocity & position
      state.velocity.add(accel.multiplyScalar(dt));
      state.position.add(state.velocity.clone().multiplyScalar(dt));

      // Keep above/at ground, simple bounce if we hit
      const groundHeight = 0; // y=0 is ground
      if (state.position.y < groundHeight + 2) {
        // rough landing / "runway"
        state.position.y = groundHeight + 2;
        if (state.velocity.y < 0) {
          state.velocity.y *= -0.1; // small bounce
        }
      }

      // Control torques
      const torque = new THREE.Vector3(
        maxControlTorque.pitch * state.pitchInput, // pitch about Z? (we'll define axes below)
        maxControlTorque.yaw * state.yawInput,
        maxControlTorque.roll * state.rollInput
      );

      // NOTE: We'll treat local axes as:
      // X = forward, Y = up, Z = right
      // For simplicity, we map: pitch -> rotate around Z, yaw -> rotate around Y, roll -> rotate around X.
      // This is not perfectly realistic but feels aircraft-like.

      // Angular acceleration (simplified: I = 1 for all axes)
      const angAccel = torque.clone(); // ignoring moment of inertia differences

      // Apply angular damping
      const dampingFactor = Math.exp(-angularDamping * dt);
      state.angularVelocity.multiplyScalar(dampingFactor);
      state.angularVelocity.add(angAccel.multiplyScalar(dt));

      // Integrate orientation using small-angle approximation
      const angVelLocal = state.angularVelocity;
      const angVelMag = angVelLocal.length();
      if (angVelMag > 0.0001) {
        const axis = angVelLocal.clone().normalize();
        const angle = angVelMag * dt;
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        state.orientation.multiply(dq).normalize();
      }

      // Update plane transform from state
      plane.position.copy(state.position);
      plane.quaternion.copy(state.orientation);

      // Rotate prop for visual effect
      prop.rotation.x += 50 * dt * state.throttle;
    }

    // === Camera: first-person-ish view ===
    function updateCamera() {
      // Cockpit position: a bit behind nose, slightly above center, inside the fuselage
      const cockpitOffset = new THREE.Vector3(2.5, 0.3, 0);
      cockpitOffset.applyQuaternion(plane.quaternion);

      const camPos = plane.position.clone().add(cockpitOffset);

      // Look forward with small mouse offset
      const baseForward = new THREE.Vector3(1, 0, 0).applyQuaternion(plane.quaternion);
      const baseUp = new THREE.Vector3(0, 1, 0).applyQuaternion(plane.quaternion);

      // Slight mouse look (limit angles)
      const lookYaw = mouseX * 0.2;   // radians
      const lookPitch = mouseY * 0.1; // radians

      const yawQuat = new THREE.Quaternion().setFromAxisAngle(baseUp, lookYaw);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(plane.quaternion);
      const pitchQuat = new THREE.Quaternion().setFromAxisAngle(right, -lookPitch);

      const lookDir = baseForward.clone().applyQuaternion(yawQuat).applyQuaternion(pitchQuat);

      camera.position.copy(camPos);
      camera.up.copy(baseUp);
      const target = camPos.clone().add(lookDir);
      camera.lookAt(target);
    }

    // === HUD ===
    const hudEl = document.getElementById('hud');

    function updateHUD() {
      const speedKts = state.velocity.length() * 1.94384; // m/s to knots
      const altitude = state.position.y;
      const throttlePct = Math.round(state.throttle * 100);

      // Simple pitch/roll estimate using forward/up vector
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(state.orientation);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);

      const pitchRad = Math.asin(forward.y);
      const pitchDeg = THREE.MathUtils.radToDeg(pitchRad);

      const rollRad = Math.atan2(rightDot(up), upDot(up));
      // but simpler: approximate roll via right/up
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(state.orientation);
      const rollRad2 = Math.atan2(right.y, right.z);
      const rollDeg = THREE.MathUtils.radToDeg(rollRad2);

      hudEl.textContent =
        `SPD: ${speedKts.toFixed(0)} kts
ALT: ${altitude.toFixed(0)} m
THR: ${throttlePct} %
PITCH: ${pitchDeg.toFixed(1)}°
ROLL: ${rollDeg.toFixed(1)}°`;
    }

    // Helpers for HUD roll calculation (keep them simple)
    function rightDot(v) { return v.dot(new THREE.Vector3(0, 0, 1)); }
    function upDot(v) { return v.dot(new THREE.Vector3(0, 1, 0)); }

    // === Main loop ===
    function animate(now) {
      requestAnimationFrame(animate);

      const dt = (now - lastTime) / 1000;
      lastTime = now;

      updateControls();
      updatePhysics(dt);
      updateCamera();
      updateHUD();

      renderer.render(scene, camera);
    }

    animate(performance.now());

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
