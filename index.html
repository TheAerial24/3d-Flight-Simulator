<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GeoFS-Style C172 Flight Sim (Ground Start)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      font-family: system-ui, sans-serif;
    }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0f0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.4;
      border-radius: 4px;
      pointer-events: none;
      white-space: pre;
    }
    #help {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="help">
    Controls:<br>
    Throttle: 0–9 (0 = idle, 9 = full)<br>
    Pitch: Up/Down arrows (Down = nose up)<br>
    Roll: Left/Right arrows<br>
    Yaw: A / D<br>
    View: V (1st / 3rd person)<br>
    Reset: R (back on the runway)
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // ===== BASIC THREE.JS SETUP =====
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87ceeb, 5000, 20000);
    scene.background = new THREE.Color(0x87ceeb); // sky

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      50000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x337733, 0.8);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(300, 400, 200);
    scene.add(dirLight);

    // ===== GROUND: GREEN WITH WHITE GRID =====
    const groundSize = 40000;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x1b7a1b });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(groundSize, 400, 0xffffff, 0xffffff);
    grid.position.y = 0.05;
    scene.add(grid);

    // ===== C172 MODEL (BUILT FROM PRIMITIVES) =====
    const plane = new THREE.Group();

    // Fuselage
    const fuselageGeo = new THREE.CylinderGeometry(0.7, 0.9, 8, 24, 1, false);
    const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
    fuselage.rotation.z = Math.PI / 2;
    plane.add(fuselage);

    // Nose
    const noseGeo = new THREE.ConeGeometry(0.9, 1.4, 24);
    const noseMat = new THREE.MeshPhongMaterial({ color: 0xd0d0d0 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.rotation.z = -Math.PI / 2;
    nose.position.set(4.5, 0, 0);
    plane.add(nose);

    // Cabin (glass-ish)
    const cabinGeo = new THREE.BoxGeometry(2.5, 1.6, 1.8);
    const cabinMat = new THREE.MeshPhongMaterial({
      color: 0x99b7ff,
      transparent: true,
      opacity: 0.8
    });
    const cabin = new THREE.Mesh(cabinGeo, cabinMat);
    cabin.position.set(1, 0.7, 0);
    plane.add(cabin);

    // Wings
    const wingGeo = new THREE.BoxGeometry(11, 0.3, 1.8);
    const wingMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, 1.1, 0);
    plane.add(wing);

    // Horizontal stabilizer
    const hStabGeo = new THREE.BoxGeometry(3.5, 0.2, 1);
    const hStabMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const hStab = new THREE.Mesh(hStabGeo, hStabMat);
    hStab.position.set(-3.6, 0.5, 0);
    plane.add(hStab);

    // Vertical stabilizer
    const vStabGeo = new THREE.BoxGeometry(0.25, 1.7, 1.1);
    const vStabMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const vStab = new THREE.Mesh(vStabGeo, vStabMat);
    vStab.position.set(-3.6, 1.1, 0);
    plane.add(vStab);

    // Propeller disc (spinning blur)
    const propGeo = new THREE.CircleGeometry(1.1, 32);
    const propMat = new THREE.MeshBasicMaterial({
      color: 0x333333,
      transparent: true,
      opacity: 0.6
    });
    const prop = new THREE.Mesh(propGeo, propMat);
    prop.rotation.y = Math.PI / 2;
    prop.position.set(5.4, 0, 0);
    plane.add(prop);

    scene.add(plane);

    // ===== FLIGHT STATE =====
    const groundHeight = 0.0;
    const gearHeight = 1.0; // plane's "wheels" height

    const state = {
      position: new THREE.Vector3(0, groundHeight + gearHeight, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      orientation: new THREE.Quaternion(),
      angularVelocity: new THREE.Vector3(0, 0, 0),
      throttle: 0.0,   // 0–1
      pitchInput: 0.0, // -1 to 1
      rollInput: 0.0,  // -1 to 1
      yawInput: 0.0,   // -1 to 1
      onGround: true
    };

    // Physics constants
    const mass = 1000;          // kg
    const g = 9.81;
    const maxThrust = 8000;     // N (enough to take off)
    const wingArea = 16;        // m^2
    const airDensity = 1.225;   // kg/m^3
    const Cd = 0.03;            // drag coefficient
    const liftSlope = 5.5;      // per rad
    const ClMax = 1.4;
    const angularDamping = 0.7;
    const maxControlTorque = {
      roll: 1.0,
      pitch: 0.9,
      yaw: 0.4
    };
    const muRoll = 0.03;        // rolling friction coefficient (small)
    const takeoffSpeed = 30;    // m/s (~58 kts) threshold

    let lastTime = performance.now();
    let cameraMode = 1; // 1 = cockpit, 3 = chase

    // ===== INPUT =====
    const keys = {};

    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;
      if (e.code.startsWith("Arrow")) e.preventDefault();

      // Throttle 0–9
      if (e.key >= "0" && e.key <= "9") {
        const num = parseInt(e.key, 10);
        if (num === 0) state.throttle = 0;
        else state.throttle = num / 9;
      }

      // View toggle
      if (e.code === "KeyV") {
        cameraMode = cameraMode === 1 ? 3 : 1;
      }

      // Reset on runway
      if (e.code === "KeyR") {
        resetPlane();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });

    function resetPlane() {
      state.position.set(0, groundHeight + gearHeight, 0);
      state.velocity.set(0, 0, 0);
      state.orientation.identity();
      state.angularVelocity.set(0, 0, 0);
      state.throttle = 0.0;
      state.onGround = true;
    }

    function updateControls() {
      // Pitch: Down arrow = nose up, Up arrow = nose down
      if (keys["ArrowDown"]) {
        state.pitchInput = 1;  // nose up
      } else if (keys["ArrowUp"]) {
        state.pitchInput = -1; // nose down
      } else {
        state.pitchInput = 0;
      }

      // Roll
      if (keys["ArrowLeft"]) {
        state.rollInput = -1;
      } else if (keys["ArrowRight"]) {
        state.rollInput = 1;
      } else {
        state.rollInput = 0;
      }

      // Yaw: A / D
      if (keys["KeyA"]) {
        state.yawInput = -1;
      } else if (keys["KeyD"]) {
        state.yawInput = 1;
      } else {
        state.yawInput = 0;
      }
    }

    // ===== PHYSICS =====
    function updatePhysics(dt) {
      dt = Math.min(dt, 0.05); // clamp big frame jumps

      // Orientation basis vectors
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(state.orientation);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(state.orientation);

      // Gravity
      const gravityForce = new THREE.Vector3(0, -mass * g, 0);

      // Velocity and relative wind
      const speed = state.velocity.length();
      const velocity = state.velocity.clone();
      const relWind = velocity.clone().negate(); // air at rest, plane moving

      // If basically stopped, skip fancy aero
      let lift = new THREE.Vector3();
      let drag = new THREE.Vector3();

      if (speed > 1) {
        const relDir = relWind.clone().normalize();

        // AoA: angle between forward and relative wind in forward-up plane
        const relForward = relDir.dot(forward);
        const relUp = relDir.dot(up);
        const alpha = Math.atan2(relUp, relForward); // radians

        let Cl = liftSlope * alpha;
        if (Cl > ClMax) Cl = ClMax;
        if (Cl < -ClMax) Cl = -ClMax;

        const q = 0.5 * airDensity * speed * speed; // dynamic pressure

        const liftMag = q * wingArea * Cl;
        lift = up.clone().multiplyScalar(liftMag);

        const dragMag = q * wingArea * Cd;
        drag = relDir.clone().multiplyScalar(dragMag); // opposite to velocity
      }

      // Thrust along forward
      const thrust = forward.clone().multiplyScalar(maxThrust * state.throttle);

      // Ground contact check
      const heightAGL = state.position.y - groundHeight - gearHeight;
      if (heightAGL <= 0.001 && state.velocity.y <= 0) {
        state.onGround = true;
        state.position.y = groundHeight + gearHeight;
        state.velocity.y = 0;
      }

      let totalForce = new THREE.Vector3();

      if (state.onGround) {
        // ----- On wheels -----
        // Vertical: we constrain to ground, so don't integrate vertical pos;
        // instead we use lift to reduce normal force.
        const liftVertical = lift.y;
        let normalMag = mass * g - liftVertical;
        if (normalMag < 0) normalMag = 0;

        // Rolling friction
        const horizVel = velocity.clone();
        horizVel.y = 0;
        const horizSpeed = horizVel.length();
        let friction = new THREE.Vector3();
        if (horizSpeed > 0.1) {
          const frictionDir = horizVel.clone().multiplyScalar(-1 / horizSpeed);
          const frictionMag = muRoll * normalMag;
          friction = frictionDir.multiplyScalar(frictionMag);
        }

        // Horizontal aerodynamic drag
        const dragHoriz = drag.clone();
        dragHoriz.y = 0;

        // Total horizontal forces
        const thrustHoriz = thrust.clone();
        thrustHoriz.y = 0;
        totalForce
          .add(thrustHoriz)
          .add(dragHoriz.multiplyScalar(-1)) // drag opposes motion
          .add(friction);

        // Takeoff condition: enough lift + speed
        if (liftVertical > mass * g * 0.9 && speed > takeoffSpeed) {
          state.onGround = false;
          // allow vertical motion now: give some upward velocity from lift
          state.velocity.y += (liftVertical - mass * g) / mass * dt * 2;
        }
      } else {
        // ----- In the air -----
        totalForce
          .add(gravityForce)
          .add(thrust)
          .add(lift)
          .add(drag.multiplyScalar(-1)); // drag opposite to motion
      }

      // Linear acceleration
      const accel = totalForce.clone().divideScalar(mass);

      // Integrate velocity & position
      state.velocity.add(accel.multiplyScalar(dt));
      state.position.add(state.velocity.clone().multiplyScalar(dt));

      // Hard ground clamp (no going through ground)
      if (!state.onGround && state.position.y < groundHeight + gearHeight) {
        state.position.y = groundHeight + gearHeight;
        if (state.velocity.y < 0) state.velocity.y = 0;
        state.onGround = true;
      }

      // ----- Rotational dynamics -----
      // Local control torques: axes X=forward, Y=up, Z=right
      let torque = new THREE.Vector3(
        maxControlTorque.roll * state.rollInput,   // around X
        maxControlTorque.yaw * state.yawInput,     // around Y
        maxControlTorque.pitch * state.pitchInput  // around Z
      );

      // On ground, limit roll/yaw at low speed
      if (state.onGround && speed < 20) {
        torque.x *= 0.2;
        torque.y *= 0.3;
      }

      // Angular acceleration (simplified: same inertia)
      const angAccel = torque.clone();

      // Damping
      const dampingFactor = Math.exp(-angularDamping * dt);
      state.angularVelocity.multiplyScalar(dampingFactor);
      state.angularVelocity.add(angAccel.multiplyScalar(dt));

      // Integrate orientation using small-angle quaternion
      const angVel = state.angularVelocity;
      const angVelMag = angVel.length();
      if (angVelMag > 0.0001) {
        const axis = angVel.clone().normalize();
        const angle = angVelMag * dt;
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        state.orientation.multiply(dq).normalize();
      }

      // If on ground, keep wings mostly level and nose near horizon
      if (state.onGround) {
        // Level roll slowly
        const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);
        const targetUp = new THREE.Vector3(0, 1, 0);
        const rollAxis = currentUp.clone().cross(targetUp);
        const rollAngle = currentUp.angleTo(targetUp);
        if (rollAngle > 0.001) {
          const corrQuat = new THREE.Quaternion()
            .setFromAxisAngle(rollAxis.normalize(), rollAngle * 0.3 * dt * 5);
          state.orientation.premultiply(corrQuat).normalize();
        }

        // Limit pitch to +/- 15 degrees on ground
        const nose = new THREE.Vector3(1, 0, 0).applyQuaternion(state.orientation);
        const pitch = Math.asin(THREE.MathUtils.clamp(nose.y, -1, 1));
        const maxPitch = THREE.MathUtils.degToRad(15);
        if (pitch > maxPitch || pitch < -maxPitch) {
          const excess = pitch > 0 ? pitch - maxPitch : pitch + maxPitch;
          const pitchAxis = right.clone();
          const corrQuat = new THREE.Quaternion()
            .setFromAxisAngle(pitchAxis, -excess * 0.5);
          state.orientation.premultiply(corrQuat).normalize();
        }
      }

      // Apply to model
      plane.position.copy(state.position);
      plane.quaternion.copy(state.orientation);

      // Spin prop
      prop.rotation.x += 80 * dt * (0.2 + state.throttle);
    }

    // ===== CAMERA =====
    function updateCamera() {
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(plane.quaternion);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(plane.quaternion);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(plane.quaternion);

      if (cameraMode === 1) {
        // Cockpit view
        const cockpitOffset = new THREE.Vector3(2.0, 0.6, 0); // inside cabin
        cockpitOffset.applyQuaternion(plane.quaternion);
        const camPos = plane.position.clone().add(cockpitOffset);
        const target = camPos.clone().add(forward);
        camera.position.copy(camPos);
        camera.up.copy(up);
        camera.lookAt(target);
      } else {
        // Chase view
        const chaseOffset = new THREE.Vector3(-15, 6, 0);
        chaseOffset.applyQuaternion(plane.quaternion);
        const camPos = plane.position.clone().add(chaseOffset);
        camera.position.copy(camPos);
        camera.up.copy(up);
        camera.lookAt(plane.position.clone().add(forward.multiplyScalar(10)));
      }
    }

    // ===== HUD =====
    const hudEl = document.getElementById("hud");
    function updateHUD() {
      const speedKts = state.velocity.length() * 1.94384; // m/s -> knots
      const altitude = state.position.y - groundHeight - gearHeight;
      const throttlePct = Math.round(state.throttle * 100);

      hudEl.textContent =
        `SPD: ${speedKts.toFixed(0)} kts
ALT: ${Math.max(0, altitude).toFixed(0)} m
THR: ${throttlePct} %
VIEW: ${cameraMode === 1 ? "COCKPIT" : "CHASE"}
GROUND: ${state.onGround ? "YES" : "NO"}`;
    }

    // ===== MAIN LOOP =====
    function animate(now) {
      requestAnimationFrame(animate);
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      updateControls();
      updatePhysics(dt);
      updateCamera();
      updateHUD();

      renderer.render(scene, camera);
    }

    animate(performance.now());

    // Resize handler
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>