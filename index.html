<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GeoFS-Style C172 Flight Sim</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      font-family: system-ui, sans-serif;
    }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0f0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.4;
      border-radius: 4px;
      pointer-events: none;
      white-space: pre;
    }
    #help {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="help">
    Controls:<br>
    Throttle: 1–9 (0 = idle)<br>
    Pitch: Up/Down arrows (Down = nose up)<br>
    Roll: Left/Right arrows<br>
    Yaw: A / D<br>
    View: V (1st / 3rd person)<br>
    Reset: R (back on the ground)
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // ===== BASIC THREE.JS SETUP =====
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87ceeb, 5000, 20000);
    scene.background = new THREE.Color(0x87ceeb); // sky

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      50000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x337733, 0.8);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(300, 400, 200);
    scene.add(dirLight);

    // ===== GROUND: GREEN WITH WHITE GRID =====
    const groundSize = 40000;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x1b7a1b });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(groundSize, 400, 0xffffff, 0xffffff);
    grid.position.y = 0.05;
    scene.add(grid);

    // ===== C172 MODEL (BUILT FROM CODE) =====
    const plane = new THREE.Group();

    // Fuselage (long tube)
    const fuselageGeo = new THREE.CylinderGeometry(0.7, 0.9, 8, 24, 1, false);
    const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
    fuselage.rotation.z = Math.PI / 2;
    plane.add(fuselage);

    // Nose cone
    const noseGeo = new THREE.ConeGeometry(0.9, 1.4, 24);
    const noseMat = new THREE.MeshPhongMaterial({ color: 0xd0d0d0 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.rotation.z = -Math.PI / 2;
    nose.position.set(4.5, 0, 0);
    plane.add(nose);

    // Cabin (glass-ish)
    const cabinGeo = new THREE.BoxGeometry(2.5, 1.6, 1.8);
    const cabinMat = new THREE.MeshPhongMaterial({
      color: 0x99b7ff,
      transparent: true,
      opacity: 0.8
    });
    const cabin = new THREE.Mesh(cabinGeo, cabinMat);
    cabin.position.set(1, 0.7, 0);
    plane.add(cabin);

    // Wings
    const wingGeo = new THREE.BoxGeometry(11, 0.3, 1.8);
    const wingMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, 1.1, 0);
    plane.add(wing);

    // Horizontal stabilizer
    const hStabGeo = new THREE.BoxGeometry(3.5, 0.2, 1);
    const hStabMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const hStab = new THREE.Mesh(hStabGeo, hStabMat);
    hStab.position.set(-3.6, 0.5, 0);
    plane.add(hStab);

    // Vertical stabilizer
    const vStabGeo = new THREE.BoxGeometry(0.25, 1.7, 1.1);
    const vStabMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const vStab = new THREE.Mesh(vStabGeo, vStabMat);
    vStab.position.set(-3.6, 1.1, 0);
    plane.add(vStab);

    // Propeller disc (spinning blur)
    const propGeo = new THREE.CircleGeometry(1.1, 32);
    const propMat = new THREE.MeshBasicMaterial({
      color: 0x333333,
      transparent: true,
      opacity: 0.6
    });
    const prop = new THREE.Mesh(propGeo, propMat);
    prop.rotation.y = Math.PI / 2;
    prop.position.set(5.4, 0, 0);
    plane.add(prop);

    scene.add(plane);

    // ===== FLIGHT STATE =====
    const state = {
      position: new THREE.Vector3(0, 2.0, 0), // just above ground
      velocity: new THREE.Vector3(25, 0, 0),  // small forward speed
      orientation: new THREE.Quaternion(),
      angularVelocity: new THREE.Vector3(0, 0, 0),
      throttle: 0.4,   // 0–1
      pitchInput: 0.0, // -1 to 1
      rollInput: 0.0,  // -1 to 1
      yawInput: 0.0,   // -1 to 1
      onGround: false
    };

    // Physics constants (tuned to feel like a light GA plane)
    const mass = 1100;          // kg
    const g = 9.81;
    const maxThrust = 3500;     // N
    const wingArea = 16;        // m^2
    const airDensity = 1.225;   // kg/m^3
    const Cd = 0.035;           // drag coefficient
    const liftSlope = 5.5;      // per rad
    const ClMax = 1.4;
    const angularDamping = 0.6;
    const maxControlTorque = {
      roll: 0.9,
      pitch: 0.7,
      yaw: 0.4
    };
    const gearHeight = 1.0;     // distance from CG to wheels
    const groundHeight = 0.0;
    const groundFriction = 1.5; // friction when rolling on ground

    let lastTime = performance.now();
    let cameraMode = 1; // 1 = cockpit, 3 = chase

    // ===== INPUT =====
    const keys = {};

    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;

      if (e.code.startsWith("Arrow")) e.preventDefault();

      // Throttle 1–9, 0 = idle
      if (e.key >= "0" && e.key <= "9") {
        const num = parseInt(e.key, 10);
        if (num === 0) state.throttle = 0;
        else state.throttle = num / 9;
      }

      // View toggle
      if (e.code === "KeyV") {
        cameraMode = cameraMode === 1 ? 3 : 1;
      }

      // Reset
      if (e.code === "KeyR") {
        resetPlane();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });

    function resetPlane() {
      state.position.set(0, 2.0, 0);
      state.velocity.set(25, 0, 0);
      state.orientation.identity();
      state.angularVelocity.set(0, 0, 0);
      state.throttle = 0.4;
      state.onGround = false;
    }

    function updateControls() {
      // Pitch: Down arrow = nose up, Up arrow = nose down
      if (keys["ArrowDown"]) {
        state.pitchInput = 1;  // nose up
      } else if (keys["ArrowUp"]) {
        state.pitchInput = -1; // nose down
      } else {
        state.pitchInput = 0;
      }

      // Roll
      if (keys["ArrowLeft"]) {
        state.rollInput = -1;
      } else if (keys["ArrowRight"]) {
        state.rollInput = 1;
      } else {
        state.rollInput = 0;
      }

      // Yaw: A / D
      if (keys["KeyA"]) {
        state.yawInput = -1;
      } else if (keys["KeyD"]) {
        state.yawInput = 1;
      } else {
        state.yawInput = 0;
      }
    }

    // ===== PHYSICS =====
    function updatePhysics(dt) {
      dt = Math.min(dt, 0.05); // clamp big frame jumps

      // Orientation basis vectors
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(state.orientation);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(state.orientation);

      // Gravity
      const gravityForce = new THREE.Vector3(0, -mass * g, 0);

      // Velocity, speed
      const speed = state.velocity.length();
      const velDir = speed > 0.0001
        ? state.velocity.clone().divideScalar(speed)
        : forward.clone();

      // Angle of attack (component in forward/up plane)
      const vVert = state.velocity.dot(up);
      const vForward = state.velocity.dot(forward);
      let alpha = 0;
      if (Math.abs(vForward) > 0.1 || Math.abs(vVert) > 0.1) {
        alpha = Math.atan2(vVert, vForward);
      }

      // Lift coefficient
      let Cl = liftSlope * alpha;
      if (Cl > ClMax) Cl = ClMax;
      if (Cl < -ClMax) Cl = -ClMax;

      const q = 0.5 * airDensity * speed * speed; // dynamic pressure
      const liftMag = q * wingArea * Cl;
      const lift = up.clone().multiplyScalar(liftMag);

      // Drag
      const dragMag = q * wingArea * Cd;
      const drag = velDir.clone().multiplyScalar(-dragMag);

      // Thrust
      const thrust = forward.clone().multiplyScalar(maxThrust * state.throttle);

      // Is plane contacting ground?
      const heightAboveGround = state.position.y - groundHeight;
      const touchingGround = heightAboveGround <= gearHeight + 0.01 && state.velocity.y <= 2;

      let totalForce = new THREE.Vector3()
        .add(gravityForce)
        .add(thrust);

      if (touchingGround) {
        // Stick to ground: don't fall through
        state.onGround = true;

        // Cancel downward movement and clamp height
        if (state.position.y < groundHeight + gearHeight) {
          state.position.y = groundHeight + gearHeight;
        }
        if (state.velocity.y < 0) {
          state.velocity.y = 0;
        }

        // Ground normal force cancels gravity vertically
        const normalForce = new THREE.Vector3(0, mass * g, 0);
        totalForce.add(normalForce);

        // Apply some lift so you can rotate for takeoff at speed
        if (lift.y > 0) {
          totalForce.add(lift);
        }

        // Ground friction only on horizontal motion
        const horizontalVel = state.velocity.clone();
        horizontalVel.y = 0;
        const horizSpeed = horizontalVel.length();
        if (horizSpeed > 0.01) {
          const frictionDir = horizontalVel.clone().multiplyScalar(-1 / horizSpeed);
          const frictionMag = groundFriction * mass * g;
          const friction = frictionDir.multiplyScalar(frictionMag);
          totalForce.add(friction);
        }
      } else {
        state.onGround = false;
        // Full aerodynamic forces in the air
        totalForce
          .add(lift)
          .add(drag);
      }

      // Linear acceleration
      const accel = totalForce.clone().divideScalar(mass);

      // Integrate velocity and position
      state.velocity.add(accel.multiplyScalar(dt));
      state.position.add(state.velocity.clone().multiplyScalar(dt));

      // Hard clamp: never go through the ground
      if (state.position.y < groundHeight + gearHeight) {
        state.position.y = groundHeight + gearHeight;
        if (state.velocity.y < 0) state.velocity.y = 0;
        state.onGround = true;
      }

      // Control torques (local axes: X forward, Y up, Z right)
      // We treat pitch around Z, yaw around Y, roll around X
      const torque = new THREE.Vector3(
        maxControlTorque.roll * state.rollInput,   // around X
        maxControlTorque.yaw * state.yawInput,     // around Y
        maxControlTorque.pitch * state.pitchInput  // around Z
      );

      // If on ground and slow, limit crazy rolling
      if (state.onGround && speed < 15) {
        torque.x *= 0.2;
        torque.z *= 0.2;
      }

      // Angular acceleration (simplified)
      const angAccel = torque.clone();

      // Angular damping
      const dampingFactor = Math.exp(-angularDamping * dt);
      state.angularVelocity.multiplyScalar(dampingFactor);
      state.angularVelocity.add(angAccel.multiplyScalar(dt));

      // Integrate orientation with small-angle quaternion
      const angVel = state.angularVelocity;
      const angVelMag = angVel.length();
      if (angVelMag > 0.0001) {
        const axis = angVel.clone().normalize();
        const angle = angVelMag * dt;
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        state.orientation.multiply(dq).normalize();
      }

      // If on ground and very slow, gently align with horizon (no weird tilt)
      if (state.onGround && speed < 2) {
        const targetUp = new THREE.Vector3(0, 1, 0);
        const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(state.orientation);
        const corrAxis = currentUp.clone().cross(targetUp);
        const corrAngle = currentUp.angleTo(targetUp);
        if (corrAngle > 0.001) {
          const corrQuat = new THREE.Quaternion().setFromAxisAngle(corrAxis.normalize(), corrAngle * 0.3);
          state.orientation.premultiply(corrQuat).normalize();
        }
      }

      // Apply to Three.js object
      plane.position.copy(state.position);
      plane.quaternion.copy(state.orientation);

      // Spin prop depending on throttle
      prop.rotation.x += 80 * dt * (0.1 + state.throttle);
    }

    // ===== CAMERA =====
    function updateCamera() {
      const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(plane.quaternion);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(plane.quaternion);
      const right = new THREE.Vector3(0, 0, 1).applyQuaternion(plane.quaternion);

      if (cameraMode === 1) {
        // Cockpit view
        const cockpitOffset = new THREE.Vector3(2.0, 0.6, 0); // inside cabin
        cockpitOffset.applyQuaternion(plane.quaternion);
        const camPos = plane.position.clone().add(cockpitOffset);
        const target = camPos.clone().add(forward);
        camera.position.copy(camPos);
        camera.up.copy(up);
        camera.lookAt(target);
      } else {
        // Chase view
        const chaseOffset = new THREE.Vector3(-12, 5, 0);
        chaseOffset.applyQuaternion(plane.quaternion);
        const camPos = plane.position.clone().add(chaseOffset);
        camera.position.copy(camPos);
        camera.up.copy(up);
        camera.lookAt(plane.position.clone().add(forward.multiplyScalar(5)));
      }
    }

    // ===== HUD =====
    const hudEl = document.getElementById("hud");
    function updateHUD() {
      const speedKts = state.velocity.length() * 1.94384; // m/s -> knots
      const altitude = state.position.y - groundHeight - gearHeight;
      const throttlePct = Math.round(state.throttle * 100);

      hudEl.textContent =
        `SPD: ${speedKts.toFixed(0)} kts
ALT: ${Math.max(0, altitude).toFixed(0)} m
THR: ${throttlePct} %
VIEW: ${cameraMode === 1 ? "COCKPIT" : "CHASE"}
GROUND: ${state.onGround ? "YES" : "NO"}`;
    }

    // ===== MAIN LOOP =====
    function animate(now) {
      requestAnimationFrame(animate);
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      updateControls();
      updatePhysics(dt);
      updateCamera();
      updateHUD();

      renderer.render(scene, camera);
    }

    animate(performance.now());

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>