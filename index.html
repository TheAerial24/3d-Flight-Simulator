<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Plane Chase Camera</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; } /* Sky Blue background */
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <h2>Flight Controls</h2>
        <p><strong>W</strong> - Pitch Down</p>
        <p><strong>S</strong> - Pitch Up</p>
        <p><strong>A</strong> - Roll Left</p>
        <p><strong>D</strong> - Roll Right</p>
        <p><strong>Space</strong> - Boost Speed</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP SCENE ---
        const scene = new THREE.Scene();
        // Add some fog for depth
        scene.fog = new THREE.Fog(0x87CEEB, 100, 900);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // --- 3. CREATE THE PLANE ---
        function createPlane() {
            const planeGroup = new THREE.Group();

            // Body (Fuselage)
            const bodyGeo = new THREE.ConeGeometry(0.5, 3, 16);
            bodyGeo.rotateX(Math.PI / 2); // Point forward
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            planeGroup.add(body);

            // Wings
            const wingGeo = new THREE.BoxGeometry(4, 0.1, 1);
            const wingMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const wings = new THREE.Mesh(wingGeo, wingMat);
            wings.position.set(0, 0, 0.5);
            planeGroup.add(wings);

            // Tail
            const tailGeo = new THREE.BoxGeometry(1.5, 0.1, 0.8);
            const tail = new THREE.Mesh(tailGeo, wingMat);
            tail.position.set(0, 0, 1.3);
            planeGroup.add(tail);

            // Vertical Stabilizer
            const vertGeo = new THREE.BoxGeometry(0.1, 1, 0.8);
            const vert = new THREE.Mesh(vertGeo, wingMat);
            vert.position.set(0, 0.5, 1.3);
            planeGroup.add(vert);

            return planeGroup;
        }

        const airplane = createPlane();
        scene.add(airplane);

        // --- 4. CREATE THE ENVIRONMENT ---
        // Infinite-looking grid
        const gridHelper = new THREE.GridHelper(2000, 50, 0x555555, 0x555555);
        gridHelper.position.y = -50;
        scene.add(gridHelper);

        // Add some random floating cubes to fly past
        const geom = new THREE.BoxGeometry(5, 5, 5);
        const mat = new THREE.MeshStandardMaterial({ color: 0x44aa88 });
        
        for (let i = 0; i < 100; i++) {
            const cube = new THREE.Mesh(geom, mat);
            cube.position.set(
                (Math.random() - 0.5) * 800,
                (Math.random() - 0.5) * 400,
                (Math.random() - 0.5) * 800
            );
            scene.add(cube);
        }

        // --- 5. CONTROLS LOGIC ---
        const keys = { w: false, a: false, s: false, d: false, space: false };

        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'w') keys.w = true;
            if (e.key.toLowerCase() === 'a') keys.a = true;
            if (e.key.toLowerCase() === 's') keys.s = true;
            if (e.key.toLowerCase() === 'd') keys.d = true;
            if (e.code === 'Space') keys.space = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'w') keys.w = false;
            if (e.key.toLowerCase() === 'a') keys.a = false;
            if (e.key.toLowerCase() === 's') keys.s = false;
            if (e.key.toLowerCase() === 'd') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });

        // --- 6. PHYSICS & UPDATE LOOP ---
        let speed = 0.5;
        const baseSpeed = 0.5;
        const boostSpeed = 1.2;

        function updatePlane() {
            // 1. Handle Speed
            if (keys.space) {
                speed = THREE.MathUtils.lerp(speed, boostSpeed, 0.1);
            } else {
                speed = THREE.MathUtils.lerp(speed, baseSpeed, 0.1);
            }

            // 2. Handle Rotation (Local Space)
            // Pitch (W/S)
            if (keys.w) airplane.rotateX(0.03); 
            if (keys.s) airplane.rotateX(-0.03);
            
            // Roll (A/D)
            if (keys.a) airplane.rotateZ(0.04);
            if (keys.d) airplane.rotateZ(-0.04);

            // Optional: Add a little automatic forward movement (Thrust)
            airplane.translateY(-speed); // In Three.js cones point up Y by default, rotated to Z
        }

        function updateCamera() {
            // CALCULATE CAMERA POSITION BEHIND PLANE
            
            // 1. Create a relative offset (Where the camera should be relative to the plane)
            // (x: 0, y: 3 up, z: 8 behind) - Note: Adjust depending on model orientation
            const relativeCameraOffset = new THREE.Vector3(0, 5, 12);

            // 2. Transform this offset based on the plane's rotation matrix
            const cameraOffset = relativeCameraOffset.applyMatrix4(airplane.matrixWorld);

            // 3. Smoothly move camera to that spot (optional smooth lerp)
            // For "Hard Lock" use: camera.position.copy(cameraOffset);
            camera.position.lerp(cameraOffset, 0.1);

            // 4. Look at the plane
            camera.lookAt(airplane.position);
        }

        function animate() {
            requestAnimationFrame(animate);

            updatePlane();
            updateCamera();

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
