<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic Cockpit Sim</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0, 255, 65, 0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instructions">ARROW KEYS to Fly</div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Resize handling
    let width, height;
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- CONFIGURATION ---
    const FRICTION = 0.99; // 1.0 is no friction (space), 0.9 is thick mud
    const THRUST_POWER = 0.15;
    const ROTATION_SPEED = 0.04;
    
    // --- STATE ---
    const keys = {};
    
    // Ship Physics State
    const ship = {
        angle: -Math.PI / 2, // Pointing up
        velX: 0,
        velY: 0,
        posX: 0, // Global world coordinates
        posY: 0
    };

    // Starfield (3D parallax effect)
    const stars = [];
    const STAR_COUNT = 200;

    class Star {
        constructor() {
            this.init();
        }
        
        init() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.z = Math.random() * 2 + 0.5; // Depth factor (0.5 to 2.5)
            this.size = Math.random() * 1.5;
        }

        update(vx, vy) {
            // Move stars opposite to ship velocity to simulate travel
            // Closer stars (higher z) move faster
            this.x -= vx * this.z;
            this.y -= vy * this.z;

            // Wrap around screen
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;
        }

        draw() {
            const alpha = Math.min(this.z / 2, 1);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Initialize Stars
    for (let i = 0; i < STAR_COUNT; i++) {
        stars.push(new Star());
    }

    // Input Handling
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    // --- DRAWING FUNCTIONS ---

    function drawCockpit() {
        // 1. Dashboard Base (Dark Grey with gradient)
        const grad = ctx.createLinearGradient(0, height - 200, 0, height);
        grad.addColorStop(0, '#1a1a1a');
        grad.addColorStop(1, '#000000');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        // Draw a trapezoid shape for the dashboard
        ctx.moveTo(0, height);
        ctx.lineTo(0, height - 150);
        ctx.lineTo(width * 0.2, height - 100);
        ctx.lineTo(width * 0.8, height - 100);
        ctx.lineTo(width, height - 150);
        ctx.lineTo(width, height);
        ctx.fill();

        // 2. Window Pillars (Struts)
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 15;
        ctx.beginPath();
        
        // Left Strut
        ctx.moveTo(0, 0); 
        ctx.lineTo(width * 0.2, height - 100);
        
        // Right Strut
        ctx.moveTo(width, 0);
        ctx.lineTo(width * 0.8, height - 100);
        
        // Top Bar
        ctx.moveTo(0, 0);
        ctx.lineTo(width, 0);
        
        ctx.stroke();

        // 3. Glass Tint (Subtle green overlay on the window part)
        // We draw the inverse of the cockpit to tint the space view
        ctx.fillStyle = 'rgba(0, 20, 0, 0.1)'; 
        ctx.fillRect(0,0,width,height);
    }

    function drawHUD() {
        // Setup HUD style (Glowing Green)
        ctx.fillStyle = '#0f0';
        ctx.strokeStyle = '#0f0';
        ctx.font = 'bold 20px "Courier New"';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 10;

        // Speed Calculation
        const speed = Math.sqrt(ship.velX**2 + ship.velY**2) * 10;
        
        // 1. Speedometer (Bottom Left)
        ctx.fillText(`VEL: ${speed.toFixed(1)} m/s`, 50, height - 50);
        
        // Bar graph for speed
        ctx.strokeRect(50, height - 40, 150, 10);
        ctx.fillRect(50, height - 40, Math.min(speed * 5, 150), 10);

        // 2. Coordinates (Bottom Right)
        const displayX = Math.floor(ship.posX);
        const displayY = Math.floor(ship.posY);
        ctx.textAlign = 'right';
        ctx.fillText(`POS: [${displayX}, ${displayY}]`, width - 50, height - 50);
        ctx.textAlign = 'left'; // Reset

        // 3. Center Crosshair
        const cx = width / 2;
        const cy = height / 2;
        
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Cross
        ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy);
        ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20);
        // Circle
        ctx.arc(cx, cy, 10, 0, Math.PI*2);
        ctx.stroke();

        // 4. Artificial Horizon Line (Simulated)
        // This line rotates opposite to the ship to show "level"
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(-ship.angle - Math.PI/2); 
        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.fillRect(-100, 1, 200, 2); // Horizon line
        ctx.restore();

        ctx.shadowBlur = 0; // Reset glow for next frame
    }

    // --- MAIN LOOP ---
    function loop() {
        // 1. Physics
        if (keys['ArrowLeft'] || keys['KeyA']) ship.angle -= ROTATION_SPEED;
        if (keys['ArrowRight'] || keys['KeyD']) ship.angle += ROTATION_SPEED;

        if (keys['ArrowUp'] || keys['KeyW']) {
            ship.velX += Math.cos(ship.angle) * THRUST_POWER;
            ship.velY += Math.sin(ship.angle) * THRUST_POWER;
        }

        // Apply Drag/Friction (Newtonian mechanics)
        ship.velX *= FRICTION;
        ship.velY *= FRICTION;

        // Update Position (Just for tracking coordinates)
        ship.posX += ship.velX;
        ship.posY += ship.velY;

        // 2. Clear Screen
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);

        // 3. Draw Space (Stars move relative to ship velocity)
        stars.forEach(star => {
            star.update(ship.velX, ship.velY);
            star.draw();
        });

        // 4. Draw Overlays
        drawCockpit();
        drawHUD();

        requestAnimationFrame(loop);
    }

    // Start
    loop();

</script>
</body>
</html>
