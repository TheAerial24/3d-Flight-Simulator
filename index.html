<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jet Sim - Solid Ground</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #33ff33;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #33ff33;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
            font-weight: bold;
            font-size: 14px;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        .bar-container {
            width: 200px;
            height: 10px;
            background: #333;
            margin-top: 5px;
            border: 1px solid #33ff33;
        }
        #throttleBar {
            width: 50%;
            height: 100%;
            background: #33ff33;
            transition: width 0.1s linear;
        }
        .status-light {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #555;
            margin-right: 5px;
        }
        .on-ground { background-color: orange; box-shadow: 0 0 5px orange; }
        .airborne { background-color: #33ff33; box-shadow: 0 0 5px #33ff33; }
    </style>
</head>
<body>

<div id="instructions">
    <b>CONTROLS:</b><br>
    ⬆ / ⬇ : Pitch (Nose Up/Down)<br>
    ⬅ / ➡ : Roll (Turn)<br>
    <b>W</b> : Throttle UP<br>
    <b>S</b> : Throttle DOWN<br>
    <i>Tip: You need speed (> 0.4 Mach) to take off!</i>
</div>

<div id="hud">
    <div><span id="statusLight" class="status-light on-ground"></span> <span id="statusText">GROUND</span></div>
    <br>
    <div>THROTTLE: <span id="throtVal">50</span>%</div>
    <div class="bar-container"><div id="throttleBar"></div></div>
    <br>
    <div>SPEED: <span id="spdVal">0.00</span> MACH</div>
    <div>ALTITUDE: <span id="altVal">0</span> FT</div>
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

    // --- CONFIGURATION ---
    const MAX_MACH = 1.5;
    const TAKEOFF_SPEED = 0.6; // Speed required to lift nose
    const INERTIA = 0.008;     // Acceleration curve
    const TURN_SPEED = 0.03;
    const GROUND_LEVEL = 1.5;  // Y height where wheels touch ground (half of jet height)

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 200, 1500); // Hides the edge of the grid

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Turn on shadows for depth perception
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const sunLight = new THREE.DirectionalLight(0xffffff, 1);
    sunLight.position.set(100, 200, 50);
    sunLight.castShadow = true;
    // Optimize shadow map
    sunLight.shadow.camera.left = -50;
    sunLight.shadow.camera.right = 50;
    sunLight.shadow.camera.top = 50;
    sunLight.shadow.camera.bottom = -50;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    scene.add(sunLight);

    // --- BUILD THE JET ---
    const jetGroup = new THREE.Group();
    
    // Fuselage
    const geometryBody = new THREE.ConeGeometry(0.5, 4, 32);
    geometryBody.rotateX(Math.PI / 2);
    const materialBody = new THREE.MeshPhongMaterial({ color: 0xdddddd, flatShading: true });
    const fuselage = new THREE.Mesh(geometryBody, materialBody);
    fuselage.castShadow = true;
    jetGroup.add(fuselage);

    // Wings
    const geometryWings = new THREE.BoxGeometry(5, 0.1, 2);
    const materialDark = new THREE.MeshPhongMaterial({ color: 0x555555 });
    const wings = new THREE.Mesh(geometryWings, materialDark);
    wings.position.set(0, 0, 0.5);
    wings.castShadow = true;
    jetGroup.add(wings);

    // Vertical Stabilizer (Tail)
    const geometryTail = new THREE.BoxGeometry(0.1, 1.2, 1.2);
    const tail = new THREE.Mesh(geometryTail, materialDark);
    tail.position.set(0, 0.6, 1.5);
    tail.castShadow = true;
    jetGroup.add(tail);

    // Engine Exhaust (Visual)
    const geometryExhaust = new THREE.CylinderGeometry(0.3, 0.1, 0.5, 10);
    geometryExhaust.rotateX(Math.PI / 2);
    const materialExhaust = new THREE.MeshBasicMaterial({ color: 0xff4500 });
    const engine = new THREE.Mesh(geometryExhaust, materialExhaust);
    engine.position.z = 2.1;
    jetGroup.add(engine);

    scene.add(jetGroup);
    jetGroup.position.y = GROUND_LEVEL; // Start on ground

    // --- THE GROUND ---
    // We make a massive plane to receive shadows
    const groundGeo = new THREE.PlaneGeometry(10000, 10000);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x2e8b57, depthWrite: false });
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.position.y = -0.1; // Just below the grid lines
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // Infinite Grid Helper
    // We create a huge grid so you can fly for a long time
    const gridHelper = new THREE.GridHelper(10000, 500, 0x000000, 0x555555);
    scene.add(gridHelper);

    // --- GAME VARIABLES ---
    let throttle = 50; 
    let speed = 0;
    let isOnGround = true;
    
    // Input State
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false };

    // --- EVENT LISTENERS ---
    window.addEventListener('keydown', (e) => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = true;
        if(e.key.toLowerCase() === 'w') keys.w = true;
        if(e.key.toLowerCase() === 's') keys.s = true;
    });
    window.addEventListener('keyup', (e) => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = false;
        if(e.key.toLowerCase() === 'w') keys.w = false;
        if(e.key.toLowerCase() === 's') keys.s = false;
    });
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- MAIN LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. Throttle Logic
        if (keys.w && throttle < 100) throttle += 0.5;
        if (keys.s && throttle > 0) throttle -= 0.5;

        // 2. Calculate Speed (Mach)
        let targetSpeed = (throttle / 100) * MAX_MACH;
        speed += (targetSpeed - speed) * INERTIA; // Smooth acceleration
        
        // 3. Move the Jet
        // Real movement through the world
        jetGroup.translateZ(-speed);

        // 4. Ground Physics Check
        if (jetGroup.position.y <= GROUND_LEVEL) {
            isOnGround = true;
            jetGroup.position.y = GROUND_LEVEL; // Snap to floor
            
            // Level the wings if on ground (Taxiing physics)
            // We gently rotate Z back to 0
            jetGroup.rotation.z *= 0.9;
            // Level pitch if not trying to takeoff
            if (!keys.ArrowUp) jetGroup.rotation.x *= 0.9;
        } else {
            isOnGround = false;
        }

        // 5. Steering Controls
        
        // PITCH (Up/Down)
        if (keys.ArrowUp) {
            // Can only pitch up if airborne OR speed is high enough to takeoff
            if (!isOnGround || speed > TAKEOFF_SPEED) {
                jetGroup.rotateX(-TURN_SPEED);
            }
        }
        if (keys.ArrowDown) {
            // Can only pitch down if airborne
            if (!isOnGround) {
                jetGroup.rotateX(TURN_SPEED);
            }
        }

        // ROLL (Left/Right)
        if (keys.ArrowLeft) {
            if (!isOnGround) jetGroup.rotateZ(TURN_SPEED); // Roll
            jetGroup.rotateY(TURN_SPEED * 0.5); // Yaw (Turn)
        }
        if (keys.ArrowRight) {
            if (!isOnGround) jetGroup.rotateZ(-TURN_SPEED); // Roll
            jetGroup.rotateY(-TURN_SPEED * 0.5); // Yaw (Turn)
        }

        // 6. Camera Follow
        const relativeOffset = new THREE.Vector3(0, 6, 18);
        const cameraOffset = relativeOffset.applyMatrix4(jetGroup.matrixWorld);
        
        // Make camera 'loose' (lag behind slightly) for speed feeling
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(jetGroup.position);

        // 7. Infinite Grid Illusion
        // To make the world feel endless, we snap the grid to the player's position
        // but locked to intervals of 100 so it doesn't look like it's sliding with us
        const gridSize = 10000;
        const cellSize = 20; // Size of grid squares
        
        // Currently using a massive static grid (10000 units). 
        // If you fly for 10 minutes straight you might hit the edge, but for this demo it's fine.
        // The shadow map follows the plane to keep shadows crisp
        sunLight.position.x = jetGroup.position.x + 50;
        sunLight.position.y = jetGroup.position.y + 200;
        sunLight.position.z = jetGroup.position.z + 50;
        sunLight.target = jetGroup;

        // 8. Update HUD & Visuals
        document.getElementById('throtVal').innerText = Math.round(throttle);
        document.getElementById('throttleBar').style.width = throttle + '%';
        document.getElementById('spdVal').innerText = speed.toFixed(2);
        
        // Altitude: (Real Y - Ground Level)
        let alt = Math.round((jetGroup.position.y - GROUND_LEVEL) * 10);
        document.getElementById('altVal').innerText = alt;

        // Status Light
        const light = document.getElementById('statusLight');
        const text = document.getElementById('statusText');
        if(isOnGround) {
            light.className = "status-light on-ground";
            text.innerText = "GROUND";
            text.style.color = "orange";
        } else {
            light.className = "status-light airborne";
            text.innerText = "AIRBORNE";
            text.style.color = "#33ff33";
        }

        // Engine flicker
        engine.scale.setScalar(0.8 + Math.random() * 0.2 * (throttle/100));
        engine.material.color.setHSL(0.05 + (throttle/500), 1, 0.5);

        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>
